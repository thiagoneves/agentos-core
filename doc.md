Context
AgentOS agents currently have no awareness of context window consumption — when the context fills up, quality degrades ("context rot") and work is lost. There's no structured handoff when a session pauses or context runs out. Agents also lack clear governance rules for when to act autonomously vs. stop for user approval. Finally, workflow phases execute strictly sequentially even when independent phases could run in parallel.

These 4 features address observability, resilience, governance, and performance.

Feature 1: Context Window Monitor
Goal: A Claude Code PostToolUse hook that monitors context usage and injects warnings when it's running low.

Files to create
src/hooks/context-monitor.js — The hook script (plain JS, runs as shell command)
Files to modify
runner-manager.ts — syncClaudeSettings() adds hooks config to .claude/settings.json
How it works
The hook runs after every tool use. It receives JSON on stdin including transcript_path
It reads the last line of the transcript JSONL to get message.usage (input_tokens + output_tokens)
Compares against 200k context window to calculate remaining %
Returns JSON on stdout with hookSpecificOutput.additionalContext when thresholds are crossed:
WARNING (≤35% remaining): "Context running low. Wrap up current task. Do not start new complex work."
CRITICAL (≤25% remaining): "STOP. Save state immediately. Run: aos pause to generate handoff file."
Debounce: only warn every 5 tool uses to avoid spam (severity escalation bypasses debounce)
Also writes context metrics to /tmp/agentos-ctx-{session_id}.json for dashboard consumption
Hook config (generated in .claude/settings.json)

{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "",
        "hooks": [{
          "type": "command",
          "command": "node <pkgRoot>/src/hooks/context-monitor.js",
          "timeout": 5
        }]
      }
    ]
  }
}
context-monitor.js pseudocode

// Read stdin JSON
// Parse transcript_path JSONL — read last line for usage stats
// Calculate: usedPct = (input_tokens + output_tokens) / 200000 * 100
// Remaining = 100 - usedPct
// If remaining <= 25%: return CRITICAL additionalContext
// If remaining <= 35%: return WARNING additionalContext
// Else: return empty (no injection)
// Write metrics to /tmp/agentos-ctx-{session_id}.json
Feature 2: Session Continuity (.continue-here.md)
Goal: Generate a structured handoff file so sessions can resume without losing context.

Files to create
src/core/session-continuity.ts — generateContinueHere() function
src/commands/pause.ts — aos pause CLI command
Files to modify
index.ts — Register aos pause command
workflow-engine.ts — Call generateContinueHere() on gate pause
runner-manager.ts — Update slash command templates to check for .continue-here.md
prompt-compiler.ts — Include .continue-here.md content in compiled prompts if it exists
session-continuity.ts

export async function generateContinueHere(session: SessionState, workflow: WorkflowDefinition): Promise<string> {
  // Reads session state + events
  // Computes: completed phases, current phase, remaining phases
  // Generates markdown file at .agentos/state/.continue-here.md
  // Returns the file path
}

export async function consumeContinueHere(agentosDir: string): Promise<string | null> {
  // Reads .continue-here.md if it exists
  // Returns content (caller should delete after using)
}
.continue-here.md format

---
session_id: session-feature-dev-123
workflow: feature-dev
phase: implement
agent: dev
timestamp: 2026-02-24T23:45:00Z
---

# Session Handoff

## Completed
- [x] plan (by @sm) — 1m 33s
- [x] implement (by @dev) — 3m 19s

## Current
- Phase: review (by @qa)
- Status: paused (context low)

## Remaining
- [ ] review (by @qa)
- [ ] done

## Next Action
Resume phase "review" with agent @qa. Read the compiled prompt at `.agentos/compiled/qa-gate-2026-02-24.prompt.md`.
aos pause command
Finds active session (reuses findActiveSession() from report.ts)
Loads session + workflow
Calls generateContinueHere()
Sets session status to paused
Prints path to .continue-here.md
prompt-compiler.ts change
In compile(), after assembleSessionContext, add:


const continueHere = await this.loadContinueHere();
// If exists, add as <continue_here> section in prompt
Slash command template update
Add to Step 2 preamble:


Before starting, check if `.agentos/state/.continue-here.md` exists.
If it does, read it for context on previous work and resume from where it left off.
Feature 3: Deviation Rules
Goal: Clear governance document that defines when agents can act autonomously vs. when they must stop.

Files to create
None (content is generated by RunnerManager)
Files to modify
runner-manager.ts — createProtocol() generates deviation rules in .agentos/core/rules/deviation-rules.md
prompt-compiler.ts — assembleRules() also loads core rules from .agentos/core/rules/ (currently only loads module rules)
deviation-rules.md (generated content)

# Deviation Rules

When executing tasks, follow these rules to decide what you can do autonomously vs. when you must stop and ask for user approval.

## AUTO-FIX (proceed silently)
Fix these inline without asking:
- Bug fixes and logic errors
- Type errors and compilation failures
- Lint violations and formatting issues
- Broken imports and missing dependencies

## AUTO-ADD (proceed, note in report)
Add these automatically and mention in the progress report:
- Missing error handling or try/catch blocks
- Input validation and null checks
- Missing auth checks or rate limiting
- Test coverage for new code

## AUTO-RESOLVE (proceed, note in report)
Resolve these to unblock progress:
- Missing environment variables (use sensible defaults)
- Blocking package dependencies (install compatible version)
- Broken imports from refactored code
- Minor config mismatches

## STOP (ask user before proceeding)
NEVER do these without explicit user approval:
- Adding new database tables or schema changes
- Changing system architecture or adding new services
- Switching libraries or frameworks
- Modifying CI/CD pipelines or deployment configs
- Deleting files or removing features
- Changes that affect other teams or external APIs
prompt-compiler.ts change
Update assembleRules() to also read from .agentos/core/rules/:


private async assembleRules(module: string): Promise<string> {
    let rulesStr = '<rules>\n';

    // Load core rules first
    const coreRulesDir = path.join(this.agentosDir, 'core', 'rules');
    rulesStr += await this.loadRulesFromDir(coreRulesDir);

    // Then module rules
    const moduleRulesDir = path.join(this.agentosDir, 'modules', module, 'rules');
    rulesStr += await this.loadRulesFromDir(moduleRulesDir);

    rulesStr += '</rules>';
    return rulesStr;
}
Feature 4: Wave-Based Parallel Execution
Goal: Allow independent workflow phases to execute in parallel within "waves".

Files to modify
config.ts — Add dependsOn to WorkflowPhaseSchema
workflow-engine.ts — Add calculateWaves(), modify execution to run waves
runner-manager.ts — Update slash command templates to show wave structure
Schema change (config.ts)

export const WorkflowPhaseSchema = z.object({
  // ... existing fields
  dependsOn: z.array(z.string()).optional(), // NEW: phase IDs this depends on
});
Note: parallel: z.boolean().optional() already exists in the schema but is unused. dependsOn is more expressive — it lets the engine compute parallelism automatically.

Wave calculation (workflow-engine.ts)

private calculateWaves(phases: WorkflowPhase[]): WorkflowPhase[][] {
  const completed = new Set<string>();
  const remaining = [...phases];
  const waves: WorkflowPhase[][] = [];

  while (remaining.length > 0) {
    const wave = remaining.filter(p => {
      const deps = p.dependsOn || [];
      return deps.every(d => completed.has(d));
    });

    if (wave.length === 0) break; // circular dependency guard

    waves.push(wave);
    wave.forEach(p => {
      completed.add(p.id);
      remaining.splice(remaining.indexOf(p), 1);
    });
  }
  return waves;
}
Execution change
Modify start() to call executeWaves() instead of executePhase(session, workflow, 0, ...):


private async executeWaves(session, workflow, config, module): Promise<void> {
  const waves = this.calculateWaves(workflow.phases);

  for (const wave of waves) {
    if (wave.length === 1) {
      // Single phase — execute normally (existing logic)
      await this.executeSinglePhase(session, wave[0], config, module);
    } else {
      // Parallel — execute all phases in wave concurrently
      console.log(`  Wave: [${wave.map(p => p.name).join(', ')}] (parallel)`);
      await Promise.all(
        wave.map(p => this.executeSinglePhase(session, p, config, module))
      );
    }
  }
  // Mark session complete
  session.status = 'completed';
  session.events.push({ timestamp: new Date().toISOString(), type: 'SESSION_COMPLETE', agent: 'master' });
  await this.saveSession(session);
}
Backward compatibility
Phases without dependsOn and without next → treated as sequential (each depends on the previous)
Phases with next → legacy sequential routing still works
Only when dependsOn is explicitly set does wave parallelism activate
Slash command template update
When waves have parallel phases, show it in the instruction:


## Wave 3 (parallel)
Execute these phases simultaneously:
- implement-api (by @dev)
- implement-ui (by @dev)
Implementation Order
Feature 3: Deviation Rules — Simplest (just template generation + assembleRules fix). No new dependencies.
Feature 2: Session Continuity — New file + CLI command + prompt integration.
Feature 1: Context Monitor — Hook script + settings.json generation. Depends on Feature 2 (aos pause).
Feature 4: Wave Execution — Most complex. Schema change + engine rewrite. Independent of 1-3.
Files Summary
File	Action	Features
src/hooks/context-monitor.js	CREATE	F1
src/core/session-continuity.ts	CREATE	F2
src/commands/pause.ts	CREATE	F2
src/core/runner-manager.ts	MODIFY	F1, F2, F3, F4
src/core/prompt-compiler.ts	MODIFY	F2, F3
src/core/workflow-engine.ts	MODIFY	F2, F4
src/types/config.ts	MODIFY	F4
src/index.ts	MODIFY	F2
Verification
npm run build — compiles without errors
aos sync in test project → verify .agentos/core/rules/deviation-rules.md is generated
aos sync → verify .claude/settings.json contains hooks config for context-monitor
aos run feature-dev → verify session starts and .continue-here.md is generated on pause
aos pause → verify .continue-here.md is written with correct handoff content
aos run feature-dev --resume <id> → verify .continue-here.md content is included in prompt and file is deleted
Create a test workflow with dependsOn fields → verify wave calculation produces correct grouping
Dashboard shows context metrics from /tmp/agentos-ctx-*.json (future enhancement)